{
    "contents" : "#-------------------------------------------------------------------------------\n#        Functions to calculate and update  *effort*, *effshare*, *catch.q*..\n#    i.e the fleets' parameters neccesary to calculate the landings and \n#    discards at age.\n#\n#    - 'fixedEffort' - (All Parameters Are Given) - so the function just returns the \n#        given FLFleetsExt object. It is used to maintain generallity.\n#    - 'SMFB' - (Simple mixed fisheries behaviour). - Everything constant e\n#        except effort that is updated based on landings or catch share. \n#       (multiple TACs so min, max Effort options are applied)\n#    - 'SSFB' - (Simple sequential fisheries behaviour). - Everything constant \n#        except effort that is updated based on landings or catch share \n#       (condition: each metier of the fleet targets only one stock)\n#\n# Dorleta GarcYYYa\n# Created: 28/10/2010 12:33:04\n# Changed: 2011-02-28 16:17:37 (ssanchez)\n#-------------------------------------------------------------------------------\n\n\n#-------------------------------------------------------------------------------\n# fixedEffort(fleets, biols, covars, fleets.ctrl, year = 1, season = 1)\n#-------------------------------------------------------------------------------\nfixedEffort <- function(fleets, biols, covars, advice, fleets.ctrl, flnm, year = 1, season = 1,...){\n    return(list(fleets = fleets, fleets.ctrl = fleets.ctrl))\n}\n\n#-------------------------------------------------------------------------------\n# SMFB(fleets, biols, covars, fleets.ctrl, year = 1, season = 1)\n#-------------------------------------------------------------------------------\nSMFB <- function(fleets, biols, covars, advice, fleets.ctrl, flnm, year = 1, season = 1,...){\n    \n    if(length(year) > 1 | length(season) > 1)\n        stop('Only one year and season is allowed' )\n\n    # If year/season/iter numerics => indicate position \n    # else names => get positions.\n    if(length(year) > 1 | length(season) > 1)\n        stop('Only one year and season is allowed' )\n    \n    dimnms <- dimnames(biols[[1]]@n) \n    \n    # 'year' dimension.\n    yr <- year\n    if(is.character(year)) yr <- which(dimnms[[2]] %in% year)\n    if(length(yr) == 0) stop('The year is outside object time range')  \n    \n    # 'season' dimension.\n    ss <- season\n    if(is.character(season)) ss <- which(dimnms[[4]] %in% season)\n    if(length(ss) == 0) stop('The season is outside object season range')  \n    \n    # Check fleets.ctrl elements.\n    if(!(fleets.ctrl[[flnm]]$restriction %in% c('catch', 'landings')))\n        stop(\"fleets.ctrl[[f]]$restriction must be equal to 'catch' or 'landings'\")\n     \n    # Dimensions.\n    nst <- length(biols);          stnms <- names(biols)\n    ns  <- dim(biols[[1]]@n)[4]\n    it  <- dim(biols[[1]]@n)[6]\n    flnms <- names(fleets)\n    \n    # Data\n    B    <- matrix(t(sapply(stnms, function(x){   # biomass in the middle of the season  [nst,it]\n                                if(dim(biols[[x]]@n)[1] > 1)\n                                    return(unitSums(quantSums(biols[[x]]@n*biols[[x]]@wt*exp(-biols[[x]]@m/2)))[,yr,,ss, drop=T])\n                                else return((biols[[x]]@n*biols[[x]]@wt)[,yr,,ss, drop=T])})) , nst,it, dimnames = list(stnms, 1:it))\n\n    N   <- lapply(stnms, function(x){   # biomass at age in the middle  of the season, list elements: [na,1,nu,1,1,it]\n                                if(dim(biols[[x]]@n)[1] > 1)\n                                    return((biols[[x]]@n*exp(-biols[[x]]@m/2))[,yr,,ss, drop = FALSE])\n                                else return((biols[[x]]@n)[,yr,,ss])})\n    names(N) <- stnms\n    \n\n                      \n    # Quota share          \n    QS   <- lapply(stnms, function(x){           # list of stocks, each stock [nf,it]\n                            # Calculate QS by fleet for the year and season\n                            yr.share    <- advice$quota.share[[x]][,yr,, drop=T]        # [nf,it]\n                            ss.share    <- fleets.ctrl$seasonal.share[[x]][,yr,,ss, drop=T]   # [nf,it]\n                            quota.share <-  matrix(yr.share*ss.share, length(flnms), it, dimnames = list(flnms, 1:it))\n                            quota.share[is.na(quota.share)] <- 0\n                            return(quota.share)})         \n    names(QS) <- stnms\n        \n    # If TAC >= B*alpha => TAC = B*alpha.\n    TAC.yr  <- matrix(advice$TAC[,yr,drop=T], nst, it, dimnames = list(stnms, 1:it))   # [nst,it]\n    CT       <- fleets.ctrl$catch.threshold[,yr,,ss, drop=T]  # [ns,it]\n    QS.ss    <- matrix(t(sapply(stnms, function(x) apply(QS[[x]],2,sum))), nst,it, dimnames = list(stnms, 1:it))  # [nst,it]\n                            \n    for(stknm in names(biols)){\n        tacos.fun <- fleets.ctrl[[flnm]][[stknm]]$TAC.OS.model\n        if(is.null(tacos.fun))   alpha <- rep(1,it)\n        else{\n            alpha <- eval(call(tacos.fun, fleets = fleets, TAC = TAC.yr, fleets.ctrl = fleets.ctrl, flnm = flnm, stknm = stknm, year = year, season = season))\n        }\n        TAC.yr[stknm,] <- TAC.yr[stknm,]*alpha \n\n    }\n                            \n    TAC <- ifelse(B*CT < TAC.yr*QS.ss, B*CT, TAC.yr*QS.ss) \n    \n    # Re-scale QS to fleet share within the season instead of season-fleet share within year.\n    QS   <- lapply(stnms, function(x){          # list of stocks, each stock [nf,it]\n                            res <- sweep(QS[[x]], 2, apply(QS[[x]],2, sum), \"/\")\n                            res[is.na(res)] <- 0 \n                            return(res)})      \n    names(QS) <- stnms\n\n    fl    <- fleets[[flnm]]\n    sts   <- catchNames(fl)\n    mtnms <- names(fl@metiers)\n    \n    # flinfo: matrix with information on which metier catch which stock.\n    fl.        <- FLFleetsExt(fl)\n    names(fl.) <- flnm\n    flinfo     <- stock.fleetInfo(fl.)\n    flinfo <-  strsplit(apply(flinfo, 1,function(x) names(which(x == 1))[1]), '&&')\n\n\n    efs.m <- matrix(t(sapply(mtnms, function(x) fl@metiers[[x]]@effshare[,yr,,ss, drop=T])), \n                    length(mtnms), it, dimnames = list(metier = mtnms, 1:it))\n    effs <- matrix(NA,length(sts), it, dimnames = list(sts, 1:it))\n    Cr.f <- matrix(NA,length(sts), it, dimnames = list(sts, 1:it))\n\n    q.m <- alpha.m <- beta.m  <- ret.m <- wd.m <- wl.m <-vector('list', length(sts))\n    names(q.m) <- names(alpha.m) <- names(beta.m) <- names(ret.m) <- names(wl.m) <- names(wd.m) <- sts\n\n    for(st in sts){     # q.m, alpha.m.... by metier but stock specific\n\n        # identify the first metier that catch stock st\n        mtst <- flinfo[[st]][2]\n            \n        age.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[1]]\n        age.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[1]]\n        age.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[1]]\n\n        unit.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[3]]\n        unit.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[3]]\n        unit.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[3]]\n\n        q.m[[st]]     <- array(0, dim = c(length(mtnms), length(age.q), length(unit.q),it),     dimnames = list(metier = mtnms, age = age.q, unit = unit.q, iter = 1:it))\n        alpha.m[[st]] <- array(0, dim = c(length(mtnms), length(age.alpha), length(unit.alpha), it), dimnames = list(metier = mtnms, age = age.q, unit = unit.alpha, iter = 1:it))\n        beta.m[[st]]  <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n        ret.m[[st]]   <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n        wl.m[[st]]    <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n        wd.m[[st]]    <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n\n\n        for(mt in mtnms){\n\n            if(!(st %in% names(fl@metiers[[mt]]@catches))) next\n                    \n            q.m[[st]][mt,,,]     <- fl@metiers[[mt]]@catches[[st]]@catch.q[,yr,,ss, drop = TRUE] \n            alpha.m[[st]][mt,,,] <- fl@metiers[[mt]]@catches[[st]]@alpha[,yr,,ss, drop = TRUE] \n            beta.m[[st]][mt,,,]  <- fl@metiers[[mt]]@catches[[st]]@beta[,yr,,ss, drop = TRUE] \n            ret.m[[st]][mt,,,]   <- fl@metiers[[mt]]@catches[[st]]@landings.sel[,yr,,ss, drop = TRUE] \n            wl.m[[st]][mt,,,]    <- fl@metiers[[mt]]@catches[[st]]@landings.wt[,yr,,ss, drop = TRUE]\n            wd.m[[st]][mt,,,]    <- fl@metiers[[mt]]@catches[[st]]@discards.wt[,yr,,ss, drop = TRUE]\n        }    \n        \n        Cr.f[st,] <- TAC[st,]*QS[[st]][flnm,]\n                \n        for(i in 1:it){          \n            effort.fun <- paste(fleets.ctrl[[flnm]][[st]][['catch.model']], 'effort', sep = '.')\n            Nst  <- array(N[[st]][drop=T],dim = dim(N[[st]])[c(1,3,6)])\n            effs[st, i] <-  eval(call(effort.fun, Cr = Cr.f[st,i],  N = Nst[,,i,drop=F], q.m = q.m[[st]][,,,i,drop=F],\n                                efs.m = efs.m[,i,drop=F], alpha.m = alpha.m[[st]][,,,i,drop=F], beta.m = beta.m[[st]][,,,i,drop=F],\n                                ret.m = ret.m[[st]][,,,i,drop=F], wl.m = wl.m[[st]][,,,i,drop=F], wd.m = wd.m[[st]][,,,i,drop=F],\n                                restriction = fleets.ctrl[[flnm]]$restriction))\n        }\n    }\n            \n    # Choose the effort.\n    eff <- effRule.SMFB(effs = effs, prev.eff = matrix(fl@effort[,yr-1,,ss,drop=T],1,it), rule = fleets.ctrl[[flnm]]$effort.restr)\n            \n    # Capacity restrictions.  \n    eff <- capacityRest.SMFB(eff, c(fl@capacity[,yr,,ss,drop=T]))                                   \n    fleets[[flnm]]@effort[,yr,,ss] <- eff \n          \n    #    save(advice,alpha.m,B,beta.m,Cr.f,CT,eff,effs,efs.m,fleets.ctrl, \n    #         q.m,QS,QS.ss,TAC,TAC.yr, file = paste(flnm, file = '.RData', sep = \"\"))\n   \n   # Update the quota share of this step and the next one if the \n   # quota share does not coincide with the actual catch. (update next one only if s < ns).\n   for(st in sts){\n    #   browser()\n        yr.share       <- advice$quota.share[[st]][flnm,yr,, drop=T]      # [it]\n        ss.share       <- t(matrix(fleets.ctrl$seasonal.share[[st]][flnm,yr,,, drop=T], ns, it))# [it,ns]\n        quota.share.OR <- matrix(t(yr.share*ss.share), ns, it)\n        # The catch.\n        catchFun <- fleets.ctrl[[flnm]][[st]][['catch.model']]\n        Nst  <- array(N[[st]][drop=T],dim = dim(N[[st]])[c(1,3,6)])\n        catchD <- eval(call(catchFun, N = Nst[,,,drop=F],  E = eff, efs.m = efs.m, q.m = q.m[[st]], alpha.m = alpha.m[[st]], beta.m = beta.m[[st]], wd.m = wd.m[[st]], wl.m = wl.m[[st]], ret.m = ret.m[[st]]))\n        itD <- ifelse(is.null(dim(catchD)), 1, length(dim(catchD)))\n        catch <- apply(catchD, itD, sum)  # sum catch along all dimensions except iterations.\n            \n        quota.share    <- updateQS.SMFB(QS = quota.share.OR, TAC = TAC.yr[st,], catch = catch, season = ss)        # [ns,it]\n                              \n        fleets.ctrl$seasonal.share[[st]][flnm,yr,,] <- t(t(quota.share)/apply(quota.share, 2,sum)) #[ns,it], doble 't' to perform correctly de division between matrix and vector.\n    }\n    \n    return(list(fleets = fleets, fleets.ctrl = fleets.ctrl))\n}\n\n#-------------------------------------------------------------------------------\n# SSFB(fleets, biols, covars, advice, fleets.ctrl, flnm, year = 1, season = 1)\n#-------------------------------------------------------------------------------\nSSFB <- function(fleets, biols, covars, advice, fleets.ctrl, flnm, year = 1, season = 1){\n  \n  if(length(year) > 1 | length(season) > 1)\n    stop('Only one year and season is allowed' )\n  \n  # If year/season/iter numerics => indicate position \n  # else names => get positions.\n  \n  dimnms <- dimnames(fleets[[flnm]]@effort)\n  \n  # 'year' dimension.\n  yr <- year\n  if(is.character(year)) yr <- which(dimnms[[2]] %in% year)\n  if(length(yr) == 0) stop('The year is outside object time range')  \n  \n  # 'season' dimension.\n  ss <- season\n  if(is.character(season)) ss <- which(dimnms[[4]] %in% season)\n  if(length(ss) == 0) stop('The season is outside object season range')  \n  \n  # Check fleets.ctrl elements.\n  if(! all(sapply(names(fleets), function(x) fleets.ctrl[[x]]$restriction %in% c('catch', 'landings'))))\n    stop(\"fleets.ctrl$restriction must be equal to 'catch' or 'landings'\")\n  \n  # Dimensions.\n  nst <- length(biols);   stnms <- names(biols)\n  nf  <- length(fleets);  flnms <- names(fleets)\n  ns  <- dim(biols[[1]]@n)[4]\n  it  <- dim(biols[[1]]@n)[6]\n  \n  # Data\n  ########\n  \n  # - seasonal biomass\n  B    <- matrix(t(sapply(stnms, function(x){   # biomass in the middle of the season (if age struct.)  [nst,it]\n    if(dim(biols[[x]]@n)[1] > 1)\n      return(unitSums(quantSums(biols[[x]]@n*biols[[x]]@wt*exp(-biols[[x]]@m/2)))[,yr,,ss, drop=T])\n    else return((biols[[x]]@n*biols[[x]]@wt)[,yr,,ss, drop=T])})) , nst,it, dimnames = list(stnms, 1:it))\n  # - seasonal biomass at age\n  Ba   <- lapply(stnms, function(x){   # biomass at age in the middle  of the season, list elements: [na,1,nu,1,1,it]\n    if(dim(biols[[x]]@n)[1] > 1)\n      return((biols[[x]]@n*biols[[x]]@wt*exp(-biols[[x]]@m/2))[,yr,,ss, drop = FALSE])\n    else return((biols[[x]]@n*biols[[x]]@wt)[,yr,,ss])})\n  names(Ba) <- stnms\n  \n  # - Quota share (by fleet for the year)         \n  QS   <- lapply(stnms, function(x){           # list of stocks, each stock [nf,it]\n    yr.share    <- advice$quota.share[[x]][,yr,, drop=T]        # [nf,it]\n    quota.share <-  matrix(yr.share, length(flnms), it, dimnames = list(flnms, 1:it))\n    quota.share[is.na(quota.share)] <- 0\n    return(quota.share)})\n  names(QS) <- stnms\n  \n  # - Remaining quotas for the fleet:\n  TAC.yr   <- matrix( ifelse( is.na(advice$TAC[,yr,drop=T]), \n                              advice$TAC[,yr-1,drop=T], advice$TAC[,yr,drop=T]), nst,it, dimnames = list(stnms, 1:it)) # [nst,it]\n  TAC.ss  <- TAC.yr * NA\n  TAC.fl  <- matrix(NA, nf, it, dimnames = list(flnms, 1:it))   # [nf,it]\n  \n  for (st in stnms) {\n    for (fl in flnms)\n      TAC.fl[fl,] <- remQ.SSFB( fleets=fleets, TAC=TAC.yr, QS=QS, ass.ss=advice.ctrl[[st]][['ass.season']], year=yr, season=ss, flnm=fl, stknm=st, ns=ns)\n    TAC.ss[st,] <- colSums(TAC.fl)  # total remaining TAC [nst,it]\n  }\n  \n  # Catch threshold\n  CT  <- fleets.ctrl$catch.threshold[,yr,,ss, drop=T]  # [ns,it]\n  # If TAC >= B*alpha => TAC = B*alpha.\n  TAC <- TAC.yr - ifelse(B[st,]*CT < TAC.ss, TAC.ss - B*CT, 0)  # [ns,it]\n  \n  # Effort dynamics\n  ###################\n  \n  fl      <- fleets[[flnm]]\n  sts     <- catchNames(fl)\n  mtnms   <- names(fl@metiers)\n  fl.ctrl <- fleets.ctrl[[flnm]]\n  \n  # flinfo: matrix with information on which metier catch which stock.\n  fl.        <- FLFleetsExt(fl)\n  names(fl.) <- flnm\n  flinfo     <- stock.fleetInfo(fl.)\n  # Check that each metier targets only one stock:\n  if ( sum(colSums(flinfo)>1)!=0 )\n    stop( paste(\"There is a metier targeting more than one stock, therefore '\",\n                flnm,\"' fleet is not valid to perform SSFB\",sep=\"\"))\n  # Check that each stock is only target for one metier:\n  if ( sum(rowSums(flinfo)>1)!=0 )\n    stop( paste(\"There is more than one metier targeting a stock, therefore '\",\n                flnm,\"' fleet is not valid to perform SSFB\",sep=\"\"))\n  flinfo <-  strsplit(apply(flinfo, 1,function(x) names(which(x == 1))[1]), '&&') # list of stocks, each stock [nf,nmt]\n  \n  if(fl.ctrl$restriction == 'catch'){\n    \n    # Expected effort:\n    # - total fleet effort\n    ef.fl <- fl@capacity[,yr,,ss, drop=T] * fl.ctrl$effectiveDay.perc[,yr,,ss, drop=T]        # [it]\n    # - effort share by metier\n    efs.m <- matrix(t(sapply(mtnms, function(x) fl@metiers[[x]]@effshare[,yr,,ss, drop=T])), \n                    length(mtnms), it, dimnames = list(metier = mtnms, 1:it))                     # [mt,it]\n    # - total effort by metier\n    ef.m <- matrix(t(sapply(mtnms, function(x) ef.fl*fl@metiers[[x]]@effshare[,yr,,ss, drop=T])), \n                   length(mtnms), it, dimnames = list(metier = mtnms, 1:it))                     # [mt,it]\n    \n    # Catch restriction and corresponding effort limit\n    Cr.f  <- matrix(NA,length(sts), it, dimnames = list(sts, 1:it))   # [nmt,it]\n    Er.f  <- matrix(NA,length(sts), it, dimnames = list(sapply( sts, function(x) flinfo[[x]][2]), 1:it)) # [nmt,it] \n    \n    q.m <- alpha.m <- beta.m  <- vector('list', length(sts))\n    names(q.m) <- names(alpha.m) <- names(beta.m) <- sts \n    \n    for(st in sts){     # q.m, alpha.m.... by metier but stock specific\n      # list of stocks, each stock [nmt,na,nu,it]\n      \n      # identify the metier that catch stock st\n      mtst <- flinfo[[st]][2]\n      \n      age.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[1]]\n      age.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[1]]\n      age.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[1]]\n      \n      unit.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[3]]\n      unit.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[3]]\n      unit.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[3]]\n      \n      q.m[[st]]     <- array(0, dim = c(length(mtnms), length(age.q), length(unit.q),it),     dimnames = list(metier = mtnms, age = age.q, unit = unit.q, iter = 1:it))\n      alpha.m[[st]] <- array(0, dim = c(length(mtnms), length(age.alpha), length(unit.alpha), it), dimnames = list(metier = mtnms, age = age.q, unit = unit.alpha, iter = 1:it))\n      beta.m[[st]]  <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n      \n      for(mt in mtnms){\n        \n        if(!(st %in% names(fl@metiers[[mt]]@catches))) next\n        \n        q.m[[st]][mt,,,]     <- fl@metiers[[mt]]@catches[[st]]@catch.q[,yr,,ss, drop = TRUE] \n        alpha.m[[st]][mt,,,] <- fl@metiers[[mt]]@catches[[st]]@alpha[,yr,,ss, drop = TRUE] \n        beta.m[[st]][mt,,,]  <- fl@metiers[[mt]]@catches[[st]]@beta[,yr,,ss, drop = TRUE] \n      }    \n      \n      # Catch restriction\n      Cr.f[st,] <- remQ.SSFB( fleets=fleets, TAC=TAC, QS=QS, ass.ss=advice.ctrl[[st]][['ass.season']], year=yr, season=ss, flnm=flnm, stknm=st, ns)\n      # Effort max refering to catch restriction (per metier) - total effort (NOT effort share)\n      effort.fun <- paste(fl.ctrl[[st]][['catch.model']], 'effort', sep = '.')\n      for ( i in 1:it) \n        if (efs.m[mtst,i] != 0 & sum(q.m[[st]][mtst,,,i,drop=F]!=0) > 0 ) {\n          Er.f[mtst,i] <- eval(call(effort.fun, Cr = Cr.f[st,i], B = B[st,i], Ba = Ba[[st]][,,,,,i,drop=F], q.m = q.m[[st]][,,,i,drop=F], \n                                    efs.m = efs.m[,i], alpha.m = alpha.m[[st]][,,,i,drop=F], beta.m = beta.m[[st]][,,,i,drop=F]))\n        } else {\n          Cr.f[st,i]   <- 0\n          Er.f[mtst,i] <- 0\n        }\n        \n      Er.f[mtst,] <- Er.f[mtst,]*efs.m[mtst,]\n      #            Er.f[mtst,] <- cobbDougInv( Cr = Cr.f[st,], B = B[st,], q.m = q.m[[st]][mtst,,,], alpha.m = alpha.m[[st]][mtst,,,], beta.m = beta.m[[st]][mtst,,,])\n    }\n    \n    # Choose the effort (by metier)\n    ef.m <- effRule.SSFB( Ba=Ba, B=B, ef.m=ef.m, efs.m=efs.m, q.m=q.m, alpha.m=alpha.m, beta.m=beta.m, fleet=fl, fleet.ctrl=fl.ctrl, flinfo=flinfo, Cr.f=Cr.f, Er.f=Er.f)\n    \n    # Total fleet effort:\n    fleets[[flnm]]@effort[,yr,,ss,] <- apply(ef.m,2,sum)\n    \n    # Effort share by metier:\n    for (mt in mtnms)\n      for (i in c(1:it))\n        if ( fleets[[flnm]]@effort[,yr,,ss,,i] ==  0) {\n            fleets[[flnm]]@metiers[[mt]]@effshare[,yr,,ss,] <- 0\n        } else {\n            fleets[[flnm]]@metiers[[mt]]@effshare[,yr,,ss,] <- ef.m[mt,] / fleets[[flnm]]@effort[,yr,,ss,]\n        }\n    \n    # Seasonal share\n    for(st in sts){\n      catchFun <- paste(fl.ctrl[[st]][['catch.model']], 'CatchFleet', sep = \".\")\n      catch <- eval(call(catchFun, Ba = Ba[[st]], B = B[st,], E = ef.fl, efs.m = efs.m, q.m = q.m[[st]], alpha.m = alpha.m[[st]], beta.m = beta.m[[st]]))\n      TAC.fl <- TAC.yr[st,] * QS[[st]][flnm,]\n      fleets.ctrl$seasonal.share[[st]][flnm,yr,,ss,] <- ifelse( TAC.fl==0, 0, catch/TAC.fl)\n    }\n    \n  } else{ # landings restriction.\n    stop('Not yet implemented')\n  } \n  \n  return(list(fleets = fleets, fleets.ctrl = fleets.ctrl))\n}\n",
    "created" : 1454533384150.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3494577069",
    "id" : "4C068C2F",
    "lastKnownWriteTime" : 1427409069,
    "path" : "~/GitHub/FLBEIA/R/OM_2a_Effort_Dynamics.R",
    "project_path" : "R/OM_2a_Effort_Dynamics.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}