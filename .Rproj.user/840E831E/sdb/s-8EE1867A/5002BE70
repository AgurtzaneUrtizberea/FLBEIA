{
    "contents" : "#-------------------------------------------------------------------------------\n#                   CATCH PRODUCTION FUNCTIONS \n#  'catch.model' argument in fleets.ctrl[[flnm]] object\n#  Catch production function defines the relationship between effort and catch.\n#\n#   - CobbDouglasBio - Catch from Cobb-Douglass production function aggregated in biomass\n#   - CobbDouglasAge - Catch from Cobb-Douglass production function by age.\n#\n#   - CobbDouglasBio.effort - Effort from Cobb-Douglass production function aggregated in biomass\n#   - CobbDouglasAge.effort - Effort from Cobb-Douglass production function by age.\n#\n# Dorleta GarcYYYa\n# Created: 03/06/2011 10:35:14\n# Changed: 03/06/2011 10:35:18\n#-------------------------------------------------------------------------------\n\n\n#-------------------------------------------------------------------------------\n#  CobbDouglasBio: E[it], B[it], q.m,efs.m,alpha.m,beta.m :: [mt,it] \n#       The function _works_ with iterations\n# ONLY FOR BIOMASS DYNAMIC POPUYLATUIONS.-\n#-------------------------------------------------------------------------------\nCobbDouglasBio   <- function(E,N, wl.m, wd.m, q.m,efs.m,alpha.m,beta.m, ret.m, rho = 1 ,...)  # dga: aYYYado a como argumento.\n                {\n    Ef  <- matrix(E,dim(efs.m)[1],dim(efs.m)[2], byrow = T)*efs.m\n    N   <- matrix(N,dim(efs.m)[1], dim(efs.m)[2],byrow = T)\n    alpha.m <- matrix(alpha.m,dim(efs.m)[1],dim(efs.m)[2])\n    wl.m <- matrix(wl.m,dim(efs.m)[1],dim(efs.m)[2])\n    wd.m <- matrix(wd.m,dim(efs.m)[1],dim(efs.m)[2])\n    beta.m <- matrix(beta.m,dim(efs.m)[1],dim(efs.m)[2])\n    ret.m <- matrix(ret.m,dim(efs.m)[1],dim(efs.m)[2])\n    q.m <- matrix(q.m,dim(efs.m)[1],dim(efs.m)[2])\n\n    C.m <-  q.m*(Ef)^alpha.m*(N*(ret.m*wl.m + (1-ret.m)*wd.m))^beta.m  #\n        \n  #  C <-  colSums(C.m)\n\n\n    Clim <- sweep(N*(ret.m*wl.m + (1-ret.m)*wd.m), 2, rho, \"*\")\n    \n    C.m <- ifelse(C.m < Clim,  C.m, Clim)\n  \n  #  C.m <- ifelse(C.m < rho*N*(ret.m*wl.m + (1-ret.m)*wd.m),  C.m, rho*N*(ret.m*wl.m + (1-ret.m)*wd.m))\n\n    return(catch =  C.m)        # [nmt,it]\n}\n\n\n#-------------------------------------------------------------------------------\n#  CobbDouglasBio.effort Cr[1], B[1], q.m,efs.m,alpha.m,beta.m :: [mt]       \n#       The function does _not_work_ with iterations\n#-------------------------------------------------------------------------------\nCobbDouglasBio.effort   <- function(Cr,N, wl.m, wd.m,q.m,efs.m,alpha.m,beta.m,ret.m, rho = 1, restriction = 'catch',...){\n\n\n    fObj <- function(E.f,Cr,N, wl.m, wd.m, q.m,efs.m,alpha.m,beta.m,ret.m, rho, restriction){\n\n\n         C.m <- CobbDouglasBio(E = E.f, N = N, wl.m = wl.m, wd.m = wd.m, q.m = q.m, efs.m = efs.m,\n                                 alpha.m = alpha.m, beta.m = beta.m, ret.m = ret.m, rho = rho)\n\n        if(restriction == 'catch') C.m <- C.m  # if restriction = catch (=> the restriction is catch not landings. )\n        else C.m <- matrix(ret.m,dim(efs.m)[1],dim(efs.m)[2])*C.m     # if restriction = landings\n        return(Cr - sum(C.m))\n    }\n    \n    # set upper limit\n    X <- 10^(0:100)\n    fobjX <- abs(sapply(X, fObj, Cr = Cr, N = N, wl.m = wl.m, wd.m = wd.m, q.m = q.m, efs.m = efs.m, alpha.m = alpha.m, beta.m = beta.m, restriction = restriction, ret.m = ret.m, rho = rho))\n    upl <- X[which(fobjX != Inf)[length(which(fobjX != Inf))]]\n\n    Cinf <- CobbDouglasBio(E = upl,N=N, wl.m = wl.m, wd.m = wd.m, q.m=q.m,efs.m=efs.m,alpha.m=alpha.m,beta.m=beta.m, ret.m = ret.m, rho = rho)\n    if((Cr - sum(Cinf))> 0) # Even with infinity effort it is not possible to catch the quota => return 'almost' infinity effort.\n        return(effort = upl)\n\n\n    NomEff <- uniroot(fObj,interval=c(0,upl),Cr=Cr,N=N, wl.m = wl.m, wd.m = wd.m,  q.m=q.m,efs.m=efs.m,alpha.m=alpha.m,beta.m=beta.m, restriction = restriction, ret.m = ret.m, rho = rho)$root\n\n    return(effort =  NomEff)\n}\n    \n\n\n#-------------------------------------------------------------------------------\n#  CobbDouglasAge :: E[it], B[na,nu,it], efs.m[mt,it], q.m,alpha.m,beta.m :: [mt,na,nu,it] \n# Res => C.m[mt,na,nu,it]\n# OUTPUT: Catch at age in weight.\n#-------------------------------------------------------------------------------\n\nCobbDouglasAge   <- function(E,N, wl.m, wd.m, ret.m,q.m,efs.m,alpha.m,beta.m,rho = 1,...){\n\n    dimq <- dim(q.m)\n    \n    Ef  <- matrix(E,dim(efs.m)[1],dim(efs.m)[2], byrow = T)*efs.m      # [mt,it]\n    Ef  <- array(Ef, dim = c(dim(Ef), dimq[2:3]))\n    Ef  <- aperm(Ef, c(1,3:4,2))   # [mt,na,nu,it] \n   \n    N <- array(N, dim = c(dim(N), dimq[1]))\n    N <- aperm(N, c(4,1:3))      # [mt,na,nu,it]\n    \n    W <- (ret.m*wl.m + (1-ret.m)*wd.m)\n\n    C.m <- q.m*(Ef)^alpha.m*(N*W)^beta.m # [mt,na,nu,it]\n    \n    Clim <- sweep(W*N,4,rho,\"*\")\n\n    C.m <- ifelse(C.m < Clim, C.m, Clim) # The truncation  of CobDoug is applied at metier level.\n\n#    C.m <- ifelse(C.m < rho*W*N, C.m,rho*W*N) # The truncation  of CobDoug is applied at metier level.\n    \n #   C <-  apply(C.m, 4,sum)\n\n    return(catch =  C.m)  # [mt,na,nu,it]\n}\n\n#-------------------------------------------------------------------------------\n#  CobbDouglasAge.Effort :: Cr[1], B[na,nu], efs.m[mt], q.m,alpha.m,beta.m :: [mt,na,nu] \n#-------------------------------------------------------------------------------\n\nCobbDouglasAge.effort   <- function(Cr,N,wl.m, wd.m, ret.m, q.m,efs.m,alpha.m,beta.m, rho = 1, restriction = 'catch',...){\n \n\n\n    fObj <- function(E.f,Cr,N,wd.m, wl.m, q.m,efs.m,alpha.m,beta.m, ret.m, rho, restriction){\n        # if catch = TRUE (=> the restriction is catch not landings. )\n\n        Ca.m <- CobbDouglasAge(E = E.f, N = N, wl.m = wl.m, wd.m = wd.m, ret.m = ret.m, q.m = q.m,\n                                 efs.m = efs.m, alpha.m = alpha.m, beta.m = beta.m, rho = rho)\n\n        if(restriction == 'catch') Ca.m <- Ca.m\n        else  Ca.m <- ret.m*Ca.m\n        \n                return(Cr - sum(Ca.m))\n    }\n\n\n    Cinf <- CobbDouglasAge(E = 1e100,Cr=Cr,N=N, wl.m = wl.m, wd.m = wd.m, q.m=q.m,efs.m=efs.m,alpha.m=alpha.m,beta.m=beta.m,  ret.m = ret.m, rho = rho)\n    if((Cr - sum(Cinf))> 0) # Even with infinity effort it is not possible to catch the quota => return 'almost' infinity effort.\n        return(effort = 1e100)\n\n    NomEff <- uniroot(fObj,interval=c(0,1e100),Cr=Cr,N=N, wl.m = wl.m, wd.m = wd.m, q.m=q.m,efs.m=efs.m,alpha.m=alpha.m,beta.m=beta.m, rho = rho,  restriction = restriction, ret.m = ret.m)$root\n\n    return(effort =  NomEff)\n}",
    "created" : 1454533819086.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3014763239",
    "id" : "5002BE70",
    "lastKnownWriteTime" : 1454534034,
    "path" : "~/GitHub/FLBEIA/R/OM_2a1_Catch_Production_Functions.R",
    "project_path" : "R/OM_2a1_Catch_Production_Functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}