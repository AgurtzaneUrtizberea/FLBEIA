{
    "collab_server" : "",
    "contents" : "#-------------------------------------------------------------------------------\n#       Update landings, discards, landings.n, discards.n slots.\n#\n# - aggregated.CobbDoug: Catch at age calculation when Cobb douglas is applied at\n#       total biomass level.\n# - ageBased.CobbDoug: Catch at age calculation when Cobb douglas is applied at\n#       age level.\n#  - updateCatch: Update the slots related to catch using the appropiate function.\n# \n# Dorleta GarcYYYa\n# Created: 28/10/2010 12:33:04\n# Changed:03/06/2011 07:53:53\n#-------------------------------------------------------------------------------\n\n\n#-------------------------------------------------------------------------------\n# updateCatch(fleets, biols, year = 1, season = 1)\n#-------------------------------------------------------------------------------\nupdateCatch <- function(fleets, biols, advice, fleets.ctrl, advice.ctrl, year = 1, season = 1){\n\n    fleet.names <- names(fleets)\n        \n    for(flnm in fleet.names){\n        # Which stocks are caught by fleet flnm.\n        flsts <- catchNames(fleets[[flnm]])\n        for(st in flsts){\n            catch.model <- paste(fleets.ctrl[[flnm]][[st]][['catch.model']], 'CAA', sep = \".\")\n            fleets <- eval(call(catch.model, fleets = fleets, biols = biols, fleets.ctrl = fleets.ctrl, advice = advice, advice.ctrl = advice.ctrl, year = year, season = season, flnm = flnm, stknm = st))\n        }\n    }\n    \n    \n     fleets <- FLFleetsExt(fleets)\n    \n    # Correct the catch in case:\n    # Age structured: Ca > (Ba*catch.threshold)\n    # Biomass: C > (B*catch.threshold)\n    fleets <- CorrectCatch(fleets = fleets, biols = biols, fleets.ctrl = fleets.ctrl, year = year, season = season)\n    \n    \n    return(fleets)\n}\n\n\n\n\n#-------------------------------------------------------------------------------\n# aggregated.CobbDoug(fleets, biols, year = 1, season = 1)\n#-------------------------------------------------------------------------------\nCobbDouglasBio.CAA  <- function(fleets, biols, fleets.ctrl, advice, year = 1, season = 1, flnm = 1, stknm = 1, ...){\n\n    rho <- fleets.ctrl[['catch.threshold']][stknm,year,,season,drop=T] # [it]\n\n    nf    <- length(fleets)\n    stnms <- names(biols)\n    nst   <- length(stnms)\n    it    <- dim(biols[[stknm]]@n)[6]\n    na    <- dim(biols[[stknm]]@n)[1]\n\n    if(na > 1) stop('CobbDouglasBio can only be applied at biomass level')\n\n    yr <- year\n    ss <- season\n    f  <- flnm\n    st <- stknm\n    \n    fleets <- unclass(fleets)\n\n    fl    <- fleets[[f]]\n    sts   <- catchNames(fl)\n    mtnms <- names(fl@metiers)\n    \n    if(!(st %in% sts)) return(fleets)\n    \n    # catch restriction, if empty => landings.\n    catch.restr <- ifelse(is.null(fleets.ctrl[[flnm]]$restriction), 'landings',ifelse(length(fleets.ctrl[[flnm]]$restriction)==1, fleets.ctrl[[flnm]]$restriction,fleets.ctrl[[flnm]]$restriction[yr]))\n                                             \n    tac <- rep('Inf',it)\n    \n    # if TAC overshoot is discarded, calculate seasonal TAC to calculate the discards.\n    TACOS <- fleets.ctrl[[flnm]][[stknm]][['discard.TAC.OS']]\n    TACOS <- ifelse(is.null(TACOS), TRUE, TACOS) \n    if(TACOS){\n        yr.share    <- advice$quota.share[[stknm]][flnm,yr,, drop=T]              # [it]\n        ss.share    <- fleets.ctrl$seasonal.share[[stknm]][flnm,yr,,ss, drop=T]   # [it]\n        QS          <- yr.share*ss.share                                          # [it]\n        QS[is.na(QS)] <- 0              \n        tac <- (advice$TAC[st,yr]*QS)[drop=T] # it\n    }\n    \n    # biomass in the middle if age struc. of the season  B[it]\n    B <- unitSums(quantSums(biols[[st]]@n*biols[[st]]@wt*exp(-biols[[st]]@m/2)))[,yr,,ss, drop=T]\n\n    N <- (biols[[stknm]]@n[,yr,,ss]*exp(-biols[[stknm]]@m[,yr,,ss]/2))  # Ba[na,1,1,1,1,it]\n            \n    efs.m <- matrix(t(sapply(mtnms, function(x) fl@metiers[[x]]@effshare[,yr,,ss, drop=T])), \n                length(mtnms), it, dimnames = list(metier = mtnms, 1:it))\n    eff   <- matrix(fl@effort[,yr,,ss],length(mtnms), it, dimnames = list(mtnms, 1:it), byrow = T)\n                     \n\n    # flinfo: matrix with information on which metier catch which stock.\n    fl.        <- FLFleetsExt(fl)\n    names(fl.) <- flnm\n    flinfo     <- stock.fleetInfo(fl.)\n    flinfo <-  strsplit(apply(flinfo, 1,function(x) names(which(x == 1))[1]), '&&')\n\n    mtst <- flinfo[[st]][2]\n\n    age.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[1]]\n    age.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[1]]\n    age.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[1]]\n\n    unit.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[3]]\n    unit.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[3]]\n    unit.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[3]]\n\n    q.m   <- array(0, dim = c(length(mtnms), length(age.q), length(unit.q),it),     dimnames = list(metier = mtnms, age = age.q, unit = unit.q, iter = 1:it))\n    alpha.m <- array(0, dim = c(length(mtnms), length(age.alpha), length(unit.alpha), it), dimnames = list(metier = mtnms, age = age.q, unit = unit.alpha, iter = 1:it))\n    beta.m  <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n    ret.m  <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n    wl.m   <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n    wd.m   <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n\n\n    for(mt in mtnms){\n\n        if(!(st %in% names(fl@metiers[[mt]]@catches))) next\n\n        q.m[mt,,,]     <- fl@metiers[[mt]]@catches[[st]]@catch.q[,yr,,ss, drop = TRUE]\n        alpha.m[mt,,,] <- fl@metiers[[mt]]@catches[[st]]@alpha[,yr,,ss, drop = TRUE]\n        beta.m[mt,,,]  <- fl@metiers[[mt]]@catches[[st]]@beta[,yr,,ss, drop = TRUE]\n        ret.m[mt,,,]   <- fl@metiers[[mt]]@catches[[st]]@landings.sel[,yr,,ss, drop = TRUE]\n        wl.m[mt,,,]    <- fl@metiers[[mt]]@catches[[st]]@landings.wt[,yr,,ss, drop = TRUE]\n        wd.m[mt,,,]    <- fl@metiers[[mt]]@catches[[st]]@discards.wt[,yr,,ss, drop = TRUE]\n    }\n\n    Nst  <- array(N[drop=T],dim = dim(N)[c(1,3,6)])\n    Cm <- CobbDouglasBio(E= eff[1,], N = N, wl.m = wl.m, wd.m = wd.m, ret.m = ret.m, q.m = q.m,\n             efs.m = efs.m, alpha.m = alpha.m, beta.m = beta.m, rho = rho)\n    \n    Ctotal <-  ifelse(rep(catch.restr == 'landings',it), apply(Cm*matrix(ret.m, dim(ret.m)[1], dim(ret.m)[4]),2,sum), apply(Cm,2,sum))\n\n    tac.disc <- ifelse(Ctotal < tac, rep(1,it), tac/Ctotal)\n\n    for(mt in 1:length(mtnms)){\n\n        if(!(st %in% names(fl@metiers[[mt]]@catches))) next\n\n        cobj <- fl@metiers[[mt]]@catches[[st]]\n\n        dsa <- cobj@discards.sel[,yr,,ss]  # [na,1,nu,1,1,it]\n        lsa <- cobj@landings.sel[,yr,,ss]  # [na,1,nu,1,1,it]\n        sa  <- (dsa + lsa)\n\n        # Recalculate dsa and lsa according to 'tac.disc'     # [na,nu,it]\n        lsa <- lsa*tac.disc\n        dsa <- sa - lsa\n\n        cobj@discards[,yr,,ss]   <- Cm[mt,]*dsa # /(sa*tac.disc)\n        cobj@landings[,yr,,ss]   <- Cm[mt,]*lsa # *tac.disc/sa\n        cobj@discards.n[,yr,,ss] <- cobj@discards[,yr,,ss]/cobj@discards.wt[,yr,,ss]\n        cobj@landings.n[,yr,,ss] <- cobj@landings[,yr,,ss]/cobj@landings.wt[,yr,,ss]\n\n        # When land.wt = 0 <-  land.n = NA => change to 0. (idem for disc.wt)\n        cobj@landings.n[,yr,,ss][is.na(cobj@landings.n[,yr,,ss])] <- 0\n        cobj@discards.n[,yr,,ss][is.na(cobj@discards.n[,yr,,ss])] <- 0\n\n        fl@metiers[[mt]]@catches[[st]] <- cobj\n\n\n        }\n          \n    fleets[[f]] <- fl\n    \n#    fleets <- FLFleetsExt(fleets)\n      \n    return(fleets)\n}\n\n            \n#-------------------------------------------------------------------------------\n# ageBased.CobbDoug(fleets, biols, year = 1, season = 1)\n#-------------------------------------------------------------------------------\nCobbDouglasAge.CAA <- function(fleets, biols, fleets.ctrl, advice, year = 1, season = 1, flnm = 1, stknm = 1,...){\n\n    rho <- fleets.ctrl[['catch.threshold']][stknm,year,, season,drop=T] # [it]\n\n    nf    <- length(fleets)\n    stnms <- names(biols)\n    nst   <- length(stnms)\n    it    <- dim(biols[[1]]@n)[6]\n    \n #   if(year == 35 & stknm == 'HKE') browser()\n\n    fleets <- unclass(fleets)\n    \n    yr <- year\n    ss <- season\n    st <- stknm\n    \n    fl    <- fleets[[flnm]]\n    sts   <- catchNames(fl)\n    mtnms <- names(fl@metiers)\n\n    if(!(st %in% sts)) return(fleets)\n    \n    tac <- rep(Inf,it)\n \n    # catch restriction, if empty => landings.\n    catch.restr <- ifelse(is.null(fleets.ctrl[[flnm]]$restriction), 'landings',ifelse(length(fleets.ctrl[[flnm]]$restriction)==1, fleets.ctrl[[flnm]]$restriction,fleets.ctrl[[flnm]]$restriction[yr]))\n\n    \n \n    #  quota share % to be upodate du to year transfer.\n    yrtr_p <- fleets.ctrl[[flnm]]$LandObl_yearTransfer_p[stknm,yr]\n    yrtr_p <- ifelse(is.null(yrtr_p), 0,yrtr_p)\n    # if year transfer was used in previous year discount it, absolute catch\n    yrtr_disc <- fleets.ctrl[[flnm]]$LandObl_discount_yrtransfer[stknm,yr-1,] # [it]\n    \n    if(is.null(yrtr_disc)) yrtr_disc <- 0\n \n    fleets.ctrl[[flnm]] \n    # if TAC overshoot is discarded, calculate seasonal TAC to calculate the discards.\n    TACOS <- fleets.ctrl[[flnm]][[stknm]][['discard.TAC.OS']]    # Is the TAC overshot discarded?\n    TACOS <- ifelse(is.null(TACOS), TRUE, TACOS) \n    if(TACOS){\n        yr.share    <- advice$quota.share[[stknm]][flnm,yr,, drop=T]              # [it]\n        ss.share    <- fleets.ctrl$seasonal.share[[stknm]][flnm,yr,,ss, drop=T]   # [it]\n        QS          <- yr.share*ss.share                                          # [it]\n        QS[is.na(QS)] <- 0              \n        tac <- ((advice$TAC[st,yr]*QS)[drop=T]*(1+yrtr_p)) - yrtr_disc # it, add yeartransfer in case it is in place, first we increment in % the quota and then we discount the cuota used in previous year. \n                                                                      # the minimise is not added because it is discarded.      \n    }\n    \n    if(dim(biols[[st]]@n)[1] == 1) stop(st, ' stock has no ages, Cobb Douglas cannot be applied at age level then! correct the \"catch.model\" argument in \"fleets.ctrl\" argument!\\n')\n    \n    N <- (biols[[st]]@n*exp(-biols[[st]]@m/2))[,yr,,ss]  # Ba[na,it], biomass at age in the middle  of the season,\n\n    efs.m <- matrix(t(sapply(mtnms, function(x) fl@metiers[[x]]@effshare[,yr,,ss, drop=T])),\n                length(mtnms), it, dimnames = list(metier = mtnms, 1:it))\n    eff   <- matrix(fl@effort[,yr,,ss],length(mtnms), it, dimnames = list(mtnms, 1:it), byrow = T)\n\n    # flinfo: matrix with information on which metier catch which stock.\n    fl.        <- FLFleetsExt(fl)\n    names(fl.) <- flnm\n    flinfo     <- stock.fleetInfo(fl.)\n    flinfo <-  strsplit(apply(flinfo, 1,function(x) names(which(x == 1))[1]), '&&')\n\n    mtst <- flinfo[[st]][2]\n\n    age.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[1]]\n    age.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[1]]\n    age.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[1]]\n\n    unit.q     <- dimnames(fl@metiers[[mtst]]@catches[[st]]@catch.q)[[3]]\n    unit.alpha <- dimnames(fl@metiers[[mtst]]@catches[[st]]@alpha)[[3]]\n    unit.beta  <- dimnames(fl@metiers[[mtst]]@catches[[st]]@beta)[[3]]\n\n    q.m   <- array(0, dim = c(length(mtnms), length(age.q), length(unit.q),it),     dimnames = list(metier = mtnms, age = age.q, unit = unit.q, iter = 1:it))\n    alpha.m <- array(0, dim = c(length(mtnms), length(age.alpha), length(unit.alpha), it), dimnames = list(metier = mtnms, age = age.q, unit = unit.alpha, iter = 1:it))\n    beta.m  <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n    ret.m  <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n    wl.m   <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n    wd.m   <- array(0, dim = c(length(mtnms), length(age.beta), length(unit.beta), it),  dimnames = list(metier = mtnms, age = age.beta,unit = unit.beta,  iter = 1:it))\n\n\n    for(mt in mtnms){\n\n        if(!(st %in% names(fl@metiers[[mt]]@catches))) next\n\n        q.m[mt,,,]     <- fl@metiers[[mt]]@catches[[st]]@catch.q[,yr,,ss, drop = TRUE]\n        alpha.m[mt,,,] <- fl@metiers[[mt]]@catches[[st]]@alpha[,yr,,ss, drop = TRUE]\n        beta.m[mt,,,]  <- fl@metiers[[mt]]@catches[[st]]@beta[,yr,,ss, drop = TRUE]\n        ret.m[mt,,,]   <- fl@metiers[[mt]]@catches[[st]]@landings.sel[,yr,,ss, drop = TRUE]\n        wl.m[mt,,,]    <- fl@metiers[[mt]]@catches[[st]]@landings.wt[,yr,,ss, drop = TRUE]\n        wd.m[mt,,,]    <- fl@metiers[[mt]]@catches[[st]]@discards.wt[,yr,,ss, drop = TRUE]\n    }\n\n    Nst  <- array(N[drop=T],dim = dim(N)[c(1,3,6)])\n\n    Cam <- CobbDouglasAge(E = eff[1,], N = Nst, wl.m = wl.m, wd.m = wd.m, ret.m = ret.m, q.m = q.m,\n                            efs.m = efs.m, alpha.m = alpha.m, beta.m = beta.m, rho = rho)\n\n # if catch restriction is landings, Lrat is calculated over landigns, else it is calculated over total catch including undersize individuals.\n    Ctotal <- ifelse(rep(catch.restr == 'landings', it), apply(Cam*ret.m,4,sum), apply(Cam,4,sum)) \n\n    tac.disc <- ifelse(Ctotal < tac, 1, tac/Ctotal)\n \n # cat('Lrat: ', tac.disc, '\\n')\n # cat('C: ', Ctotal, '\\n')\n\n    Cam <- array(Cam, dim = c(length(mtnms),dim(biols[[st]]@n)[1], 1, dim(biols[[st]]@n)[3],1,it))\n\n    for(mt in 1:length(mtnms)){\n\n        Ca <- array(Cam[mt,,,,,], dim = c(dim(biols[[st]]@n)[1], 1, dim(biols[[st]]@n)[3],1,1,it))\n\n        if(!(st %in% names(fl@metiers[[mt]]@catches))) next\n        cobj <- fl[[mt]][[st]]\n\n\n        na <- dim(q.m)[2]\n        nu <- ifelse(is.na(dim(q.m)[3]), 1, dim(q.m)[3])\n\n        efm <- array(eff[1,]*efs.m[mt,], dim = c(it,na,1,nu,1,1))\n        efm <- aperm(efm, c(2:6,1))\n\n        dsa <- cobj@discards.sel[,yr,,ss]  # [na,1,nu,1,1,it]\n        lsa <- cobj@landings.sel[,yr,,ss]  # [na,1,nu,1,1,it]\n        sa  <- (dsa + lsa)  \n            \n        # Recalculate dsa and lsa according to 'tac.disc'     # [na,nu,it]\n        lsa <- lsa*tac.disc\n        dsa <- sa - lsa             # [na,nu,it]\n\n        cobj@discards.n[,yr,,ss] <- Ca*dsa/sa/cobj@discards.wt[,yr,,ss]\n        cobj@landings.n[,yr,,ss] <- Ca*lsa/sa/cobj@landings.wt[,yr,,ss]\n\n        # When sa = 0 <-  land.n & dis.n = NA => change to 0.\n        cobj@landings.n[,yr,,ss][is.na(cobj@landings.n[,yr,,ss])] <- 0\n        cobj@discards.n[,yr,,ss][is.na(cobj@discards.n[,yr,,ss])] <- 0\n\n        cobj@discards[,yr,,ss] <- apply(Ca*dsa/sa,c(2,4,6),sum,na.rm=T)\n        cobj@landings[,yr,,ss] <- apply(Ca*lsa/sa,c(2,4,6),sum,na.rm=T)\n\n        fl@metiers[[mt]]@catches[[st]] <- cobj          \n    }\n    \n    fleets[[flnm]] <- fl\n    \n#    fleets <- FLFleetsExt(fleets)\n    \n    return(fleets)\n}\n\n\n#-------------------------------------------------------------------------------\n# seasonshare.CAA(fleets, biols, fleets.ctrl, advice, year = 1, season = 1, flnm = 1, stknm = 1, ...)\n#-------------------------------------------------------------------------------\n# Estimates catch at age, when catches are derived from fixed season share allocation by metier\n\nseasonshare.CAA  <- function(fleets, biols, fleets.ctrl, advice, advice.ctrl, year = 1, season = 1, flnm = 1, stknm = 1, ...){\n  \n  # No overshoot allowed\n  \n  nf    <- length(fleets)\n  flnms <- names(fleets)\n  stnms <- names(biols)\n  nst   <- length(stnms)\n  ns    <- dim(biols[[1]]@n)[4] \n  it    <- dim(biols[[1]]@n)[6]\n  \n  yr <- year\n  ss <- season\n  f  <- flnm\n  st <- stknm\n  \n  ass.ss <- advice.ctrl[[st]][['ass.season']]\n  if (is.null(ass.ss)) { ass.ss <- ns } else if (is.na(ass.ss)) { ass.ss <- ns }\n  \n  fleets <- unclass(fleets)\n  \n  fl    <- fleets[[f]]\n  sts   <- catchNames(fl)\n  mtnms <- names(fl@metiers)\n  \n  if(!(st %in% sts)) return(fleets)\n  \n  yy <- ifelse( ss > ass.ss | ass.ss == ns, yr, yr-1)  # for cases when TAC it's not set for natural year\n  TAC <- advice$TAC[st,yy]\n  \n  \n  # Find dependencies:\n  fl.rel <- fleets.ctrl[[flnm]][[stknm]]$catch.dependence\n  if (!is.null(fl.rel)) {\n    if (!(fl.rel %in% flnms)) \n      stop(\"catch.dependence value not valid for '\",flnm,\"' fleet and '\",stknm,\"' stock, fleet '\",fl.rel,\"' not found\")\n    fleets.ctrl$seasonal.share[[stknm]][flnm,yr,,ss,] <- fleets.ctrl$seasonal.share[[stknm]][fl.rel,yr,,ss,]\n  }\n  \n  yr.share    <- advice$quota.share[[stknm]][flnm,yr,, drop=T]              # [it]\n  ss.share    <- fleets.ctrl$seasonal.share[[stknm]][flnm,yr,,ss, drop=T]   # [it]\n  QS          <- yr.share*ss.share                                          # [it]\n  QS[is.na(QS)] <- 0\n  \n  Ctotal <- (TAC*QS)[drop=T]\n  \n  Ba <- biols[[stknm]]@n[,yr,,ss]*biols[[stknm]]@wt[,yr,,ss]*exp(-biols[[stknm]]@m[,yr,,ss]/2)  # Ba[na,1,1,1,1,it]\n  B  <- apply(Ba, c(2:6), sum)[drop=T]                                                          # B [it]\n  \n  CT  <- fleets.ctrl$catch.threshold[st,yr,,ss, drop=T]  # [ns,it]\n  \n  Ctotal <- ifelse(B*CT < Ctotal, B*CT, Ctotal)\n  \n  # Check that each metier target only one stock and vice verse\n  fl. <- FLFleetsExt(fl); names(fl.) <- flnm\n  flinfo     <- stock.fleetInfo(fl.)\n  if ( sum(colSums(stock.fleetInfo(fl.))>1)!=0 )\n    stop( paste(\"There is a metier targeting more than one stock, therefore not possible \n                  to use 'seasonshare' catch.model for '\",flnm,\"' fleet\",sep=\"\"))\n  if ( sum(rowSums(stock.fleetInfo(fl.))>1)!=0 )\n    stop( paste(\"There is a metier targeting more than one stock, therefore not possible \n                  to use 'seasonshare' catch.model for '\",flnm,\"' fleet\",sep=\"\"))\n  flinfo <-  strsplit(apply(flinfo, 1,function(x) names(which(x == 1))[1]), '&&')\n  mt <- flinfo[[st]][2] # metier that captures stock st\n  \n  cobj <- fl@metiers[[mt]]@catches[[st]]\n  \n  dsa <- cobj@discards.sel[,yr,,ss]  # [na,1,nu,1,1,it]\n  lsa <- cobj@landings.sel[,yr,,ss]  # [na,1,nu,1,1,it]\n  sa  <- (dsa + lsa)  \n  \n  if(dim(biols[[st]]@n)[1] == 1){\n    cobj@discards[,yr,,ss]   <- Ctotal*dsa # /(sa*tac.disc)\n    cobj@landings[,yr,,ss]   <- Ctotal*lsa # *tac.disc/sa\n    cobj@discards.n[,yr,,ss] <- cobj@discards[,yr,,ss]/cobj@discards.wt[,yr,,ss]\n    cobj@landings.n[,yr,,ss] <- cobj@landings[,yr,,ss]/cobj@landings.wt[,yr,,ss]\n    \n    fl@metiers[[mt]]@catches[[st]] <- cobj\n  }\n  else{ # age structured stock\n    #     browser() \n    Bs <- apply(sa*Ba, 6,sum)           # it\n    Ca <- sweep(sa*Ba, c(2,4:6), Ctotal/Bs, \"*\") # [na,nu,it]\n    Ca <- ifelse( is.na(Ca), 0, Ca)\n    \n    cobj@discards.n[,yr,,ss] <- Ca*dsa/sa/cobj@discards.wt[,yr,,ss]\n    cobj@landings.n[,yr,,ss] <- Ca*lsa/sa/cobj@landings.wt[,yr,,ss]\n    \n    # When sa = 0 <-  land.n & dis.n = NA => change to 0.\n    cobj@landings.n[,yr,,ss][is.na(cobj@landings.n[,yr,,ss])] <- 0\n    cobj@discards.n[,yr,,ss][is.na(cobj@discards.n[,yr,,ss])] <- 0\n    \n    cobj@landings[,yr,,ss] <- apply(cobj@landings.n[,yr,,ss]*cobj@landings.wt[,yr,,ss],c(2,4,6),sum)\n    cobj@discards[,yr,,ss] <- apply(cobj@discards.n[,yr,,ss]*cobj@discards.wt[,yr,,ss],c(2,4,6),sum)\n    \n    fl@metiers[[mt]]@catches[[st]] <- cobj\n  }\n  \n  fleets[[f]] <- fl\n  \n  fleets <- FLFleetsExt(fleets)\n  \n  return(fleets)\n}\n\n            \n#-------------------------------------------------------------------------------\n# CorrectCatch(fleets, biols, year = 1, season = 1)\n# Given that in some production functions it can happen that\n# Ca > Ba (age struc. pop) or C > B (bio struc. pop), if this happens the\n# catch is corrected setting Ca = Ba and C = B. For this end the catch is reduced\n# in the same degree in all the fleets. This could imply a 'revision' in the\n# production function parameters for the year, season and iteration in question\n# but it is not done internally because it does not affect other steps and it\n# would imply a los in the generality of the 'CorrectCatch' function because in\n# for doing so the catch production function should be used.\n#-------------------------------------------------------------------------------\n\nCorrectCatch <- function(fleets, biols, fleets.ctrl, year = 1, season = 1,...){\n\n    fleets <- unclass(fleets)\n    yr <- year\n    ss <- season\n    it    <- dim(biols[[1]]@n)[6]\n    nst <- length(biols)\n    \n    stnms <- names(biols)\n    flnms <- names(fleets)             \n    \n    cth <-  matrix(fleets.ctrl$catch.threshold[,year,,season,drop=T],nst,it, \n                dimnames = list(dimnames(fleets.ctrl$catch.threshold)[[1]], 1:it)) # matrix[nstk,nit]\n\n    Ba   <- lapply(stnms, function(x){   # biomass at age in the middle  of the season, list elements: [na,it] if age structured, [1,it] if biomass.\n                            if(dim(biols[[x]]@n)[1] > 1)\n                                return((biols[[x]]@n*exp(-biols[[x]]@m/2))[,yr,,ss])\n                            else return(matrix((biols[[x]]@n*biols[[x]]@wt)[,yr,,ss],1,it))})\n    names(Ba) <- stnms\n\n    B    <- matrix(t(sapply(stnms, function(x){   # biomass in the middle if age struc. of the season  [ns,it]\n                if(dim(biols[[x]]@n)[1] > 1)\n                    return(unitSums(quantSums(biols[[x]]@n*biols[[x]]@wt*exp(-biols[[x]]@m/2)))[,yr,,ss, drop=T])\n                else return((biols[[x]]@n*biols[[x]]@wt)[,yr,,ss, drop=T])})) , nst,it, dimnames = list(stnms, 1:it))\n\n\n    for(st in stnms){\n    \n   #    print(st)\n\n        if(dim(Ba[[st]])[1] > 1){ # age structured\n\n            Cat  <- catchStock(fleets, st)[,yr,,ss]\n            \n            # Convert the [age,unit] combination into a continuous age.\n            Ba.  <- unit2age(Ba[[st]]) # [na*nu,1,1,it]\n            Cat. <- unit2age(Cat)\n            K.   <- array(1,dim = dim(Ba.))   # Catch multipliers\n\n            # CORRECT Ca if Ca > Ba, the correction is common for all the fleets.\n            for(i in 1:it){\n\n                if(any((Ba[[st]][,,,,,i]*cth[st,i] - Cat[,,,,,i]) < 0)){\n\n                    cat('Ba*cth < Ca, for some \"a\" in stock',st, ', and iteration ', i,  '\\n')\n\n                    a.minus         <- which(Ba.[,,,i]*cth[st,i] < Cat.[,,,i])\n                    a.plus          <- which(Ba.[,,,i]*cth[st,i] >= Cat.[,,,i])\n                    K.[a.minus,,,i] <- Ba.[a.minus,,,i]*cth[st,i]/Cat.[a.minus,,,i]\n\n                    # The correction below would correspond with a compensation of the decrease in 'a.minus' ages.\n                    # K.[a.plus,,,i]  <- (Ct[i] - sum(Ba.[a.minus,,,i]))/sum(Cat.[a.plus,,,i])\n                }\n            }\n            K <- age2unit(K., Ba[[st]])  # [na,1,nu,1,1,it]\n            K[1,,-(1:ss)] <- 1   # This recruits do not exists  yet.\n        }\n        else{ # biomass dynamic.\n        #   browser()\n            Ct  <- c(catchWStock(fleets, st)[,yr,,ss,drop = F])  #[it]\n            Bst <- c(array(B[st,], dim = c(1,1,1,1,1,it)))     # [it]\n            K   <- rep(1,it)  # Catch multipliers\n\n            if(any((Bst*cth[st,] - Ct) < 0)){\n                i.minus <-  which((Bst*cth[st,] - Ct) < 0)\n                cat('B*cth < C, for  stock',st, ', and iteration(s) ', i.minus,  '\\n')\n                K[i.minus] <- Bst[i.minus]*cth[st,i.minus]/Ct[i.minus]\n\n            }\n\n            K <- FLQuant(K, dimnames = dimnames(biols[[st]]@n[,yr,,ss]))\n        }\n\n        if(all(K==1)) next\n        # Correct the catch fleet by fleet.\n        # does the fleet_metier catch the stock??  which of them catch the stock??\n        flinfo  <- stock.fleetInfo(fleets)\n        flmtpos <-  colnames(flinfo)[which(flinfo[st, ] == 1)]\n\n        for(k in flmtpos){\n            k. <- strsplit(k, \"&&\")[[1]]\n            fl <- k.[1]\n            mt <- k.[2]\n\n            cobj <- fleets[[fl]][[mt]][[st]]\n            \n     #       print(c(cobj@landings.n[14,yr,,ss]))\n     \n\n            cobj@landings.n[,yr,,ss] <-  cobj@landings.n[,yr,,ss]*K\n            cobj@discards.n[,yr,,ss] <-  cobj@discards.n[,yr,,ss]*K\n            cobj@landings[,yr,,ss]   <-  apply((cobj@landings.n*cobj@landings.wt)[,yr,,ss], c(2,4,6), sum)\n            cobj@discards[,yr,,ss]   <-  apply((cobj@discards.n*cobj@discards.wt)[,yr,,ss], c(2,4,6), sum)\n\n     #        print(c(cobj@landings.n[14,yr,,ss]))\n             \n           fleets[[fl]]@metiers[[mt]]@catches[[st]] <- cobj\n        }\n        \n        \n    }\n    \n    fleets <- FLFleetsExt(fleets)\n    return(fleets)\n}\n\n\n\n\n                            \n\n##-------------------------------------------------------------------------------\n## CobbDouglasBio.CatchFleet(effort, Ba, q.m, efs.m, alpha.m, beta.m)\n##-------------------------------------------------------------------------------\n#CobbDouglasBio.CatchFleet <- function(effort, N, wl.m, wd.m, ret.m, q.m, efs.m, alpha.m, beta.m,...){\n#\n#    nmt <- dim(efs.m)[1]\n#    it  <- dim(efs.m)[2]\n#\n#   ## Redimensionate all the objects into dimension [nmt,it]\n#\n#    # dim(q.m) = dim(alpha.m) = dim(beta.m) = [nmt,na,nu,it]\n#    q.m     <- matrix(q.m[,,,,drop=TRUE],nmt,it)      # [nmt,it]\n#    alpha.m <- matrix(alpha.m[,,,,drop=TRUE],nmt,it)  # [nmt,it]\n#    beta.m  <- matrix(beta.m[,,,,drop=TRUE],nmt,it)   # [nmt,it]\n#    wl.m     <- matrix(wl.m[,,,,drop=TRUE],nmt,it)   # [nmt,it]\n#    wd.m     <- matrix(wd.m[,,,,drop=TRUE],nmt,it)   # [nmt,it]\n#    ret.m     <- matrix(ret.m[,,,,drop=TRUE],nmt,it)   # [nmt,it]\n#    # dim(B) = dim(effort) = [it]\n#    N       <- matrix(N, nmt, it, byrow = TRUE)      # [nmt,it]\n#    effort  <- matrix(effort, nmt, it, byrow = TRUE) # [nmt,it]\n#\n#    catch <- apply(q.m*(effort*efs.m)^alpha.m*(N*(ret.m*wl.m + (1-ret.m)*wd.m))^beta.m,2,sum) # sum catch along metiers\n#\n#    return(catch)\n#}\n#\n##\n###-------------------------------------------------------------------------------\n### CobbDouglasAge.CatchFleet(effort, Ba, q.m, efs.m, alpha.m, beta.m)\n###-------------------------------------------------------------------------------\n#CobbDouglasAge.CatchFleet <- function(effort, N, ret.m, wl.m, wd.m, q.m, efs.m, alpha.m, beta.m,...){\n#\n#    dimq  <- dim(q.m)\n#    zz    <- ifelse(dimq == 1, FALSE, TRUE)\n#\n#    N <- array(N, dim = c(dim(q.m)[2:4], dim(q.m)[1]))  # [na,nuYYY?,itYYY?,mt]\n#    N <- aperm(N, c(4,1:3))  # [mt,na,nu,it]\n#\n#    effort <- array(effort, dim = c(length(effort), dim(q.m)[1:3])) # [it,mt,na,nu]\n#    effort <- aperm(effort, c(2:4,1))  # [mt,na,nu,it]\n#\n#    efs.m <- array(efs.m, dim = c(dim(efs.m), dimq[2:3]))\n#    efs.m <- aperm(efs.m, c(1,3:4,2))\n#\n#    catch <- apply(q.m*(effort*efs.m)^alpha.m*(N*(ret.m*wl.m + (1-ret.m)*wd.m))^beta.m, 4,sum)\n#\n#    return(catch)\n#}\n#\n#\n#\n#\n##\n",
    "created" : 1486057282601.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3107860932",
    "id" : "4FF86622",
    "lastKnownWriteTime" : 1486057744,
    "last_content_update" : -2147483648,
    "path" : "~/GitHub/FLBEIA/R/OM_2b_Update_catch.R",
    "project_path" : "R/OM_2b_Update_catch.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}